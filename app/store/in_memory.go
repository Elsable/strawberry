package store

import (
	"errors"
	"log"
	"strconv"
	"sync"
)

// ErrKeyNotFound helps to differ missed key from store issues
type ErrKeyNotFound struct {
	ResourceID string
}

func (err ErrKeyNotFound) Error() string {
	return "Resource not found for resourceID=" + err.ResourceID
}

// InMemory implements store.Interface with concurrent map
type InMemory struct {
	sync.Mutex
	data map[string]Resource
}

// New makes new store
func New() *InMemory {
	log.Print("[INFO] in-memory (ephemeral) store")
	result := InMemory{data: make(map[string]Resource)}
	return &result
}

// Create to map with autogenerated uuid as a key
func (s *InMemory) Create(r Resource) (string, error) {

	s.Lock()
	defer s.Unlock()

	s.data[r.ID] = r
	log.Printf("[DEBUG] Created %s", r.String())
	return r.ID, nil
}

// Get by key
func (s *InMemory) Get(resourceID string) (Resource, error) {

	s.Lock()
	defer s.Unlock()
	r, ok := s.data[resourceID]

	if !ok {
		log.Printf("[INFO] not found %s", resourceID)
		return r, ErrKeyNotFound{ResourceID: resourceID}
	}

	return r, nil
}

// List of resources. Use limit = 0 to get all resources
func (s *InMemory) List(limit int) (*[]Resource, error) {
	s.Lock()
	defer s.Unlock()

	if limit < 0 {
		return nil, errors.New("Limit should be >= 0 but was " + strconv.Itoa(limit))
	}
	count := len(s.data)
	if limit == 0 || limit > count {
		limit = count
	}
	list := make([]Resource, limit)

	i := 0
	for _, v := range s.data {
		list[i] = v
		i++
		if i == limit {
			break
		}
	}

	return &list, nil
}

// Delete by key
func (s *InMemory) Delete(resourceID string) (err error) {
	s.Lock()
	defer s.Unlock()
	delete(s.data, resourceID)
	log.Printf("[DEBUG] removed %s", resourceID)
	return nil
}
