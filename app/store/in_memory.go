package store

import (
	"errors"
	"log"
	"sync"
)

// InMemory implements store.Interface with concurrent map
type InMemory struct {
	sync.Mutex
	data map[string]Resource
}

// New makes new store
func New() *InMemory {
	log.Print("[INFO] in-memory (ephemeral) store")
	result := InMemory{data: make(map[string]Resource)}
	return &result
}

// Create to map with autogenerated uuid as a key
func (s *InMemory) Create(r Resource) (string, error) {

	s.Lock()
	defer s.Unlock()

	s.data[r.ID] = r
	log.Printf("[DEBUG] Created %s", r.String())
	return r.ID, nil
}

// Get by key
func (s *InMemory) Get(resourceID string) (Resource, error) {

	s.Lock()
	defer s.Unlock()
	r, ok := s.data[resourceID]

	if !ok {
		log.Printf("[INFO] not found %s", resourceID)
		return r, errors.New("Resource not found for resourceID=" + resourceID)
	}

	return r, nil
}

// List contains all resources
func (s *InMemory) List(limit int) (list *[]Resource, err error) {
	s.Lock()
	defer s.Unlock()

	l := make([]Resource, len(s.data))

	i := 0
	for _, v := range s.data {
		l[i] = v
		i++
	}

	return &l, nil
}

// Delete by key
func (s *InMemory) Delete(resourceID string) (err error) {
	s.Lock()
	defer s.Unlock()
	delete(s.data, resourceID)
	log.Printf("[DEBUG] removed %s", resourceID)
	return nil
}
